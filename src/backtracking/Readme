回溯算法
回溯法按深度优先策略搜索问题的解空间树。首先从根节点出发搜索解空间树，当算法搜索至解空间树的某一节点时，先利用剪枝函数判断该节点是否可行（即能得到问题的解）。如果不可行，则跳过对该节点为根的子树的搜索，逐层向其祖先节点回溯；否则，进入该子树，继续按深度优先策略搜索。
回溯法的基本行为是搜索，搜索过程使用剪枝函数来为了避免无效的搜索。剪枝函数包括两类：1. 使用约束函数，剪去不满足约束条件的路径；2.使用限界函数，剪去不能得到最优解的路径。
回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的节点，从而减少状态空间树节点的生成，提高了效率。
回溯算法一般都采用递归实现。回溯利用递归的性质，从问题的起始点出发，不断地进行尝试，回头一步甚至多步再做选择，直到最终抵达终点。
回溯解题模板
function backtrack(n, used) {
    // 判断输入或者状态是否非法
    if (input/state is invalid) {
        return;
  	}
    // 判读递归是否应当结束，满足结束条件就返回结果
    if (match condition) {
        return some value;
  	}
    // 遍历当前所有可能出现的情况，并尝试每一种情况
    for (all possible cases) {
        // 如果上一步尝试会影响下一步尝试，需要写入状态
        used.push(case)
        // 递归进行下一步尝试，搜索该子树
        result = backtrack(n + 1, used)
        // 在这种情况下已经尝试完毕，重置状态，以便于下面的回溯尝试
        used.pop(case)
    }
}